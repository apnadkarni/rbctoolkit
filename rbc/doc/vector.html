<!-- Creator     : groff version 1.22.3 -->
<!-- CreationDate: Mon Feb 26 16:53:52 2018 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>vector</title>

</head>
<body>

<h1 align="center">vector</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#INTRODUCTION">INTRODUCTION</a><br>
<a href="#EXAMPLE">EXAMPLE</a><br>
<a href="#SYNTAX">SYNTAX</a><br>
<a href="#VECTOR OPERATIONS">VECTOR OPERATIONS</a><br>
<a href="#INSTANCE OPERATIONS">INSTANCE OPERATIONS</a><br>
<a href="#C LANGUAGE API">C LANGUAGE API</a><br>
<a href="#LIBRARY ROUTINES">LIBRARY ROUTINES</a><br>
<a href="#C API EXAMPLE">C API EXAMPLE</a><br>
<a href="#INCOMPATIBILITIES">INCOMPATIBILITIES</a><br>
<a href="#KEYWORDS">KEYWORDS</a><br>

<hr>

<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">vector &minus;
Vector data type for Tcl</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>vector
create</b> <i>vecName</i> ?<i>vecName</i>...?
?<i>switches</i>?</p>

<p style="margin-left:11%; margin-top: 1em"><b>vector
destroy</b> <i>vecName</i> ?<i>vecName</i>...?</p>

<p style="margin-left:11%; margin-top: 1em"><b>vector
expr</b> <i>expression</i></p>

<p style="margin-left:11%; margin-top: 1em"><b>vector
    names</b> ?<i>pattern</i>...?</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The
<b>vector</b> command creates a vector of floating point
values. The vector&rsquo;s components can be manipulated in
three ways: through a Tcl array variable, a Tcl command, or
the C API.</p>

<h2>INTRODUCTION
<a name="INTRODUCTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">A vector is
simply an ordered set of numbers. The components of a vector
are real numbers, indexed by counting numbers.</p>

<p style="margin-left:11%; margin-top: 1em">Vectors are
common data structures for many applications. For example, a
graph may use two vectors to represent the X-Y coordinates
of the data plotted. The graph will automatically be redrawn
when the vectors are updated or changed. By using vectors,
you can separate data analysis from the graph widget. This
makes it easier, for example, to add data transformations,
such as splines. It&rsquo;s possible to plot the same data
to in multiple graphs, where each graph presents a different
view or scale of the data.</p>

<p style="margin-left:11%; margin-top: 1em">You could try
to use Tcl&rsquo;s associative arrays as vectors. Tcl arrays
are easy to use. You can access individual elements randomly
by specifying the index, or the set the entire array by
providing a list of index and value pairs for each element.
The disadvantages of associative arrays as vectors lie in
the fact they are implemented as hash tables.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>There&rsquo;s no implied ordering to the associative
arrays. If you used vectors for plotting, you would want to
insure the second component comes after the first, an so on.
This isn&rsquo;t possible since arrays are actually hash
tables. For example, you can&rsquo;t get a range of values
between two indices. Nor can you sort an array.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>Arrays consume lots of memory when the number of
elements becomes large (tens of thousands). This is because
each element&rsquo;s index and value are stored as strings
in the hash table.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="2%"></td>
<td width="86%">


<p>The C programming interface is unwieldy. Normally with
vectors, you would like to view the Tcl array as you do a C
array, as an array of floats or doubles. But with hash
tables, you must convert both the index and value to and
from decimal strings, just to access an element in the
array. This makes it cumbersome to perform operations on the
array as a whole.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The
<b>vector</b> command tries to overcome these disadvantages
while still retaining the ease of use of Tcl arrays. The
<b>vector</b> command creates both a new Tcl command and
associate array which are linked to the vector components.
You can randomly access vector components though the
elements of array. Not have all indices are generated for
the array, so printing the array (using the <b>parray</b>
procedure) does not print out all the component values. You
can use the Tcl command to access the array as a whole. You
can copy, append, or sort vector using its command. If you
need greater performance, or customized behavior, you can
write your own C code to manage vectors.</p>

<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You create
vectors using the <b>vector</b> command and its
<b>create</b> operation.</p>

<pre style="margin-left:22%; margin-top: 1em"># Create a new vector.
vector create y(50)</pre>


<p style="margin-left:11%; margin-top: 1em">This creates a
new vector named <tt>y</tt>. It has fifty components, by
default, initialized to <tt>0.0</tt>. In addition, both a
Tcl command and array variable, both named <tt>y</tt>, are
created. You can use either the command or variable to query
or modify components of the vector.</p>

<pre style="margin-left:22%; margin-top: 1em"># Set the first value.
set y(0) 9.25
puts &quot;y has [y length] components&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">The array
<tt>y</tt> can be used to read or set individual components
of the vector. Vector components are indexed from zero. The
array index must be a number less than the number of
components. For example, it&rsquo;s an error if you try to
set the 51st element of <tt>y</tt>.</p>

<pre style="margin-left:22%; margin-top: 1em"># This is an error. The vector only has 50 components.
set y(50) 0.02</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
specify a range of indices using a colon (:) to separate the
first and last indices of the range.</p>

<pre style="margin-left:22%; margin-top: 1em"># Set the first six components of y
set y(0:5) 25.2</pre>


<p style="margin-left:11%; margin-top: 1em">If you
don&rsquo;t include an index, then it will default to the
first and/or last component of the vector.</p>

<pre style="margin-left:22%; margin-top: 1em"># Print out all the components of y
puts &quot;y = $y(:)&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">There are
special non-numeric indices. The index <tt>end</tt>,
specifies the last component of the vector. It&rsquo;s an
error to use this index if the vector is empty (length is
zero). The index <tt>++end</tt> can be used to extend the
vector by one component and initialize it to a specific
value. You can&rsquo;t read from the array using this index,
though.</p>

<pre style="margin-left:22%; margin-top: 1em"># Extend the vector by one component.
set y(++end) 0.02</pre>


<p style="margin-left:11%; margin-top: 1em">The other
special indices are <tt>min</tt> and <tt>max</tt>. They
return the current smallest and largest components of the
vector.</p>

<pre style="margin-left:22%; margin-top: 1em"># Print the bounds of the vector
puts &quot;min=$y(min) max=$y(max)&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">To delete
components from a vector, simply unset the corresponding
array element. In the following example, the first component
of <tt>y</tt> is deleted. All the remaining components of
<tt>y</tt> will be moved down by one index as the length of
the vector is reduced by one.</p>

<pre style="margin-left:22%; margin-top: 1em"># Delete the first component
unset y(0)
puts &quot;new first element is $y(0)&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">The
vector&rsquo;s Tcl command can also be used to query or set
the vector.</p>

<pre style="margin-left:22%; margin-top: 1em"># Create and set the components of a new vector
vector create x
x set { 0.02 0.04 0.06 0.08 0.10 0.12 0.14 0.16 0.18 0.20 }</pre>


<p style="margin-left:11%; margin-top: 1em">Here
we&rsquo;ve created a vector <tt>x</tt> without a initial
length specification. In this case, the length is zero. The
<b>set</b> operation resets the vector, extending it and
setting values for each new component.</p>

<p style="margin-left:11%; margin-top: 1em">There are
several operations for vectors. The <b>range</b> operation
lists the components of a vector between two indices.</p>

<pre style="margin-left:22%; margin-top: 1em"># List the components
puts &quot;x = [x range 0 end]&quot;</pre>


<p style="margin-left:11%; margin-top: 1em">You can search
for a particular value using the <b>search</b> operation. It
returns a list of indices of the components with the same
value. If no component has the same value, it returns
<tt>&quot;&quot;</tt>.</p>

<pre style="margin-left:22%; margin-top: 1em"># Find the index of the biggest component
set indices [x search $x(max)]</pre>


<p style="margin-left:11%; margin-top: 1em">Other
operations copy, append, or sort vectors. You can append
vectors or new values onto an existing vector with the
<b>append</b> operation.</p>

<pre style="margin-left:22%; margin-top: 1em"># Append assorted vectors and values to x
x append x2 x3 { 2.3 4.5 } x4</pre>


<p style="margin-left:11%; margin-top: 1em">The <b>sort</b>
operation sorts the vector. If any additional vectors are
specified, they are rearranged in the same order as the
vector. For example, you could use it to sort data points
represented by x and y vectors.</p>

<pre style="margin-left:22%; margin-top: 1em"># Sort the data points
x sort y</pre>


<p style="margin-left:11%; margin-top: 1em">The vector
<tt>x</tt> is sorted while the components of <tt>y</tt> are
rearranged so that the original x,y coordinate pairs are
retained.</p>

<p style="margin-left:11%; margin-top: 1em">The <b>expr</b>
operation lets you perform arithmetic on vectors. The result
is stored in the vector.</p>

<pre style="margin-left:22%; margin-top: 1em"># Add the two vectors and a scalar
x expr { x + y }
x expr { x * 2 }</pre>


<p style="margin-left:11%; margin-top: 1em">When a vector
is modified, resized, or deleted, it may trigger call-backs
to notify the clients of the vector. For example, when a
vector used in the <b>graph</b> widget is updated, the
vector automatically notifies the widget that it has
changed. The graph can then redrawn itself at the next idle
point. By default, the notification occurs when Tk is next
idle. This way you can modify the vector many times without
incurring the penalty of the graph redrawing itself for each
change. You can change this behavior using the <b>notify</b>
operation.</p>

<pre style="margin-left:22%; margin-top: 1em"># Make vector x notify after every change
x notify always
  ...
# Never notify
x notify never
  ...
# Force notification now
x notify now</pre>


<p style="margin-left:11%; margin-top: 1em">To delete a
vector, use the <b>vector delete</b> command. Both the
vector and its corresponding Tcl command are destroyed.</p>

<pre style="margin-left:22%; margin-top: 1em"># Remove vector x
vector destroy x</pre>


<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Vectors are
created using the <b>vector create</b> operation. Th
<b>create</b> operation can be invoked in one of three
forms: <b><br>
vector create</b> <i>vecName</i></p>

<p style="margin-left:22%;">This creates a new vector
<i>vecName</i> which initially has no components.</p>

<p style="margin-left:11%;"><b>vector create</b>
<i>vecName</i>(<i>size</i>)</p>

<p style="margin-left:22%;">This second form creates a new
vector which will contain <i>size</i> number of components.
The components will be indexed starting from zero (0). The
default value for the components is <tt>0.0</tt>.</p>

<p style="margin-left:11%;"><b>vector create</b>
<i>vecName</i>(<i>first</i>:<i>last</i>)</p>

<p style="margin-left:22%;">The last form creates a new
vector of indexed <i>first</i> through <i>last</i>.
<i>First</i> and <i>last</i> can be any integer value so
long as <i>first</i> is less than <i>last</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Vector names
must start with a letter and consist of letters, digits, or
underscores.</p>

<pre style="margin-left:22%; margin-top: 1em"># Error: must start with letter
vector create 1abc</pre>


<p style="margin-left:11%; margin-top: 1em">You can
automatically generate vector names using the
&quot;<tt>#auto</tt>&quot; vector name. The <b>create</b>
operation will generate a unique vector name.</p>

<pre style="margin-left:22%; margin-top: 1em">set vec [vector create #auto]
puts &quot;$vec has [$vec length] components&quot;</pre>


<p style="margin-left:11%; margin-top: 1em"><b>VECTOR
INDICES</b> <br>
Vectors are indexed by integers. You can access the
individual vector components via its array variable or Tcl
command. The string representing the index can be an
integer, a numeric expression, a range, or a special
keyword.</p>

<p style="margin-left:11%; margin-top: 1em">The index must
lie within the current range of the vector, otherwise an an
error message is returned. Normally the indices of a vector
are start from 0. But you can use the <b>offset</b>
operation to change a vector&rsquo;s indices on-the-fly.</p>

<pre style="margin-left:22%; margin-top: 1em">puts $vecName(0)
vecName offset -5
puts $vecName(-5)</pre>


<p style="margin-left:11%; margin-top: 1em">You can also
use numeric expressions as indices. The result of the
expression must be an integer value.</p>

<pre style="margin-left:22%; margin-top: 1em">set n 21
set vecName($n+3) 50.2</pre>


<p style="margin-left:11%; margin-top: 1em">The following
special non-numeric indices are available: <tt>min</tt>,
<tt>max</tt>, <tt>end</tt>, and <tt>++end</tt>.</p>

<pre style="margin-left:22%; margin-top: 1em">puts &quot;min = $vecName($min)&quot;
set vecName(end) -1.2</pre>


<p style="margin-left:11%; margin-top: 1em">The indices
<tt>min</tt> and <tt>max</tt> will return the minimum and
maximum values of the vector. The index <tt>end</tt> returns
the value of the last component in the vector. The index
<tt>++end</tt> is used to append new value onto the vector.
It automatically extends the vector by one component and
sets its value.</p>

<pre style="margin-left:22%; margin-top: 1em"># Append an new component to the end
set vecName(++end) 3.2</pre>


<p style="margin-left:11%; margin-top: 1em">A range of
indices can be indicated by a colon (:).</p>

<pre style="margin-left:22%; margin-top: 1em"># Set the first six components to 1.0
set vecName(0:5) 1.0</pre>


<p style="margin-left:11%; margin-top: 1em">If no index is
supplied the first or last component is assumed.</p>

<pre style="margin-left:22%; margin-top: 1em"># Print the values of all the components
puts $vecName(:)</pre>


<h2>VECTOR OPERATIONS
<a name="VECTOR OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>vector
create</b> <i>vecName</i>?(<i>size</i>)?...
?<i>switches</i>?</p>

<p style="margin-left:22%;">The <b>create</b> operation
creates a new vector <i>vecName</i>. Both a Tcl command and
array variable <i>vecName</i> are also created. The name
<i>vecName</i> must be unique, so another Tcl command or
array variable can not already exist in that scope. You can
access the components of the vector using its variable. If
you change a value in the array, or unset an array element,
the vector is updated to reflect the changes. When the
variable <i>vecName</i> is unset, the vector and its Tcl
command are also destroyed.</p>

<p style="margin-left:22%; margin-top: 1em">The vector has
optional switches that affect how the vector is created.
They are as follows: <b><br>
&minus;variable</b> <i>varName</i></p>

<p style="margin-left:32%;">Specifies the name of a Tcl
variable to be mapped to the vector. If the variable already
exists, it is first deleted, then recreated. If
<i>varName</i> is the empty string, then no variable will be
mapped. You can always map a variable back to the vector
using the vector&rsquo;s <b>variable</b> operation.</p>

<p style="margin-left:22%;"><b>&minus;command</b>
<i>cmdName</i></p>

<p style="margin-left:32%;">Maps a Tcl command to the
vector. The vector can be accessed using <i>cmdName</i> and
one of the vector instance operations. A Tcl command by that
name cannot already exist. If <i>cmdName</i> is the empty
string, no command mapping will be made.</p>

<p style="margin-left:22%;"><b>&minus;watchunset</b>
<i>boolean</i></p>

<p style="margin-left:32%;">Indicates that the vector
should automatically delete itself if the variable
associated with the vector is unset. By default, the vector
will not be deleted. This is different from previous
releases. Set <i>boolean</i> to &quot;true&quot; to get the
old behavior.</p>

<p style="margin-left:11%;"><b>vector destroy</b>
<i>vecName</i> ?<i>vecName...</i>? <b><br>
vector expr</b> <i>expression</i></p>

<p style="margin-left:22%;">All binary operators take
vectors as operands (remember that numbers are treated as
one-component vectors). The exact action of binary operators
depends upon the length of the second operand. If the second
operand has only one component, then each element of the
first vector operand is computed by that value. For example,
the expression &quot;x * 2&quot; multiples all elements of
the vector x by 2. If the second operand has more than one
component, both operands must be the same length. Each pair
of corresponding elements are computed. So &quot;x + y&quot;
adds the the first components of x and y together, the
second, and so on.</p>

<p style="margin-left:22%; margin-top: 1em">The valid
operators are listed below, grouped in decreasing order of
precedence:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>&minus; !</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Unary minus and logical NOT. The unary minus flips the
sign of each component in the vector. The logical not
operator returns a vector of whose values are 0.0 or 1.0.
For each non-zero component 1.0 is returned, 0.0
otherwise.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>^</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Exponentiation.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>* / %</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Multiply, divide, remainder.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>+ &minus;</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Add and subtract.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>&lt;&lt; &gt;&gt;</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Left and right shift. Circularly shifts the values of
the vector (not implemented yet).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>&lt; &gt; &lt;= &gt;=</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Boolean less, greater, less than or equal, and greater
than or equal. Each operator returns a vector of ones and
zeros. If the condition is true, 1.0 is the component value,
0.0 otherwise.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>== !=</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Boolean equal and not equal. Each operator returns a
vector of ones and zeros. If the condition is true, 1.0 is
the component value, 0.0 otherwise.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>|</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Bit-wise OR. (Not implemented).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>&amp;&amp;</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Logical AND. Produces a 1 result if both operands are
non-zero, 0 otherwise.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><b>||</b></p></td>
<td width="12%"></td>
<td width="48%">


<p>Logical OR. Produces a 0 result if both operands are
zero, 1 otherwise.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="18%">


<p><i>x</i><b>?</b><i>y</i><b>:</b><i>z</i></p></td>
<td width="12%"></td>
<td width="48%">


<p>If-then-else, as in C. (Not implemented yet).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">See the C
manual for more details on the results produced by each
operator. All of the binary operators group left-to-right
within the same precedence level.</p>

<p style="margin-left:22%; margin-top: 1em">Several
mathematical functions are supported for vectors. Each of
the following functions invokes the math library function of
the same name; see the manual entries for the library
functions for details on what they do. The operation is
applied to all elements of the vector returning the
results.</p>

<p style="margin-left:32%; margin-top: 1em"><b>acos cos
hypot sinh</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="-14%"></td>
<td width="19%">


<p><b>asin</b></p></td>
<td width="17%">


<p><b>cosh</b></p></td>
<td width="46%">


<p><b>log</b></p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="-14%"></td>
<td width="19%"></td>
<td width="17%"></td>
<td width="46%">


<p><b>sqrt</b></p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="-14%"></td>
<td width="19%">


<p><b>atan</b></p></td>
<td width="17%">


<p><b>exp</b></p></td>
<td width="46%">


<p><b>log10</b></p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="-14%"></td>
<td width="19%"></td>
<td width="17%"></td>
<td width="46%">


<p><b>tan</b></p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="-14%"></td>
<td width="19%">


<p><b>ceil</b></p></td>
<td width="17%">


<p><b>floor</b></p></td>
<td width="46%">


<p><b>sin</b></p></td></tr>
<tr valign="top" align="left">
<td width="32%"></td>
<td width="-14%"></td>
<td width="19%"></td>
<td width="17%"></td>
<td width="46%">


<p><b>tanh</b></p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Additional
functions are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p style="margin-top: 1em"><b>abs</b></p></td>
<td width="5%"></td>
<td width="63%">


<p style="margin-top: 1em">Returns the absolute value of
each component.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>random</b></p></td>
<td width="5%"></td>
<td width="63%">


<p>Returns a vector of non-negative values uniformly
distributed between [0.0, 1.0) using <i>drand48</i>. The
seed comes from the internal clock of the machine or may be
set manual with the srandom function.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>round</b></p></td>
<td width="5%"></td>
<td width="63%">


<p>Rounds each component of the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="10%">


<p><b>srandom</b></p></td>
<td width="5%"></td>
<td width="63%">


<p>Initializes the random number generator using
<i>srand48</i>. The high order 32-bits are set using the
integral portion of the first vector component. All other
components are ignored. The low order 16-bits are set to an
arbitrary value.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The following
functions return a single value.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p style="margin-top: 1em"><b>adev</b></p></td>
<td width="3%"></td>
<td width="63%">


<p style="margin-top: 1em">Returns the average deviation
(defined as the sum of the absolute values of the
differences between component and the mean, divided by the
length of the vector).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>kurtosis</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the degree of peakedness (fourth moment) of the
vector.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>length</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the number of components in the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>max</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the vector&rsquo;s maximum value.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>mean</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the mean value of the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>median</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the median of the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>min</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the vector&rsquo;s minimum value.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>q1</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the first quartile of the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>q3</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the third quartile of the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>prod</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the product of the components.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>sdev</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the standard deviation (defined as the square
root of the variance) of the vector.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>skew</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the skewness (or third moment) of the vector.
This characterizes the degree of asymmetry of the vector
about the mean.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>sum</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the sum of the components.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="12%">


<p><b>var</b></p></td>
<td width="3%"></td>
<td width="63%">


<p>Returns the variance of the vector. The sum of the
squared differences between each component and the mean is
computed. The variance is the sum divided by the length of
the vector minus 1.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The last set
returns a vector of the same length as the argument.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>norm</b></p></td>
<td width="9%"></td>
<td width="63%">


<p style="margin-top: 1em">Scales the values of the vector
to lie in the range [0.0..1.0].</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>sort</b></p></td>
<td width="9%"></td>
<td width="63%">


<p>Returns the vector components sorted in ascending
order.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>vector names</b>
?<i>pattern</i>?</p>

<h2>INSTANCE OPERATIONS
<a name="INSTANCE OPERATIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can also
use the vector&rsquo;s Tcl command to query or modify it.
The general form is <i>vecName operation</i> ?<i>arg</i>?...
Both <i>operation</i> and its arguments determine the exact
behavior of the command. The operations available for
vectors are listed below. <i><br>
vecName</i> <b>append</b> <i>item</i> ?<i>item</i>?...</p>

<p style="margin-left:22%;">Appends the component values
from <i>item</i> to <i>vecName</i>. <i>Item</i> can be
either the name of a vector or a list of numeric values.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>binread</b>
<i>channel</i> ?<i>length</i>? ?<i>switches</i>?</p>

<p style="margin-left:22%;">Reads binary values from a Tcl
channel. Values are either appended to the end of the vector
or placed at a given index (using the <b>&minus;at</b>
option), overwriting existing values. Data is read until EOF
is found on the channel or a specified number of values
<i>length</i> are read (note that this is not necessarily
the same as the number of bytes). The following switches are
supported:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>&minus;swap</b></p></td>
<td width="3%"></td>
<td width="68%">


<p>Swap bytes and words. The default endian is the host
machine.</p> </td></tr>
</table>

<p style="margin-left:22%;"><b>&minus;at</b>
<i>index</i></p>

<p style="margin-left:32%;">New values will start at vector
index <i>index</i>. This will overwrite any current
values.</p>

<p style="margin-left:22%;"><b>&minus;format</b>
<i>format</i></p>

<p style="margin-left:32%;">Specifies the format of the
data. <i>Format</i> can be one of the following:
&quot;i1&quot;, &quot;i2&quot;, &quot;i4&quot;,
&quot;i8&quot;, &quot;u1, &quot;u2&quot;, &quot;u4&quot;,
&quot;u8&quot;, &quot;r4&quot;, &quot;r8&quot;, or
&quot;r16&quot;. The number indicates the number of bytes
required for each value. The letter indicates the type:
&quot;i&quot; for signed, &quot;u&quot; for unsigned,
&quot;r&quot; or real. The default format is
&quot;r16&quot;.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>clear</b></p>

<p style="margin-left:22%;">Clears the element indices from
the array variable associated with <i>vecName</i>. This
doesn&rsquo;t affect the components of the vector. By
default, the number of entries in the Tcl array
doesn&rsquo;t match the number of components in the vector.
This is because its too expensive to maintain decimal
strings for both the index and value for each component.
Instead, the index and value are saved only when you read or
write an element with a new index. This command removes the
index and value strings from the array. This is useful when
the vector is large.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>delete</b>
<i>index</i> ?<i>index</i>?...</p>

<p style="margin-left:22%;">Deletes the <i>index</i>th
component from the vector <i>vecName</i>. <i>Index</i> is
the index of the element to be deleted. This is the same as
unsetting the array variable element <i>index</i>. The
vector is compacted after all the indices have been
deleted.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>dup</b>
<i>destName</i></p>

<p style="margin-left:22%;">Copies <i>vecName</i> to
<i>destName</i>. <i>DestName</i> is the name of a
destination vector. If a vector <i>destName</i> already
exists, it is overwritten with the components of
<i>vecName</i>. Otherwise a new vector is created.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>expr</b>
<i>expression</i></p>

<p style="margin-left:22%;">Computes the expression and
resets the values of the vector accordingly. Both scalar and
vector math operations are allowed. All values in
expressions are either real numbers or names of vectors. All
numbers are treated as one component vectors.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>length</b>
?<i>newSize</i>?</p>

<p style="margin-left:22%;">Queries or resets the number of
components in <i>vecName</i>. <i>NewSize</i> is a number
specifying the new size of the vector. If <i>newSize</i> is
smaller than the current size of <i>vecName</i>,
<i>vecName</i> is truncated. If <i>newSize</i> is greater,
the vector is extended and the new components are
initialized to <tt>0.0</tt>. If no <i>newSize</i> argument
is present, the current length of the vector is
returned.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>merge</b>
<i>srcName</i> ?<i>srcName</i>?...</p>

<p style="margin-left:22%;">Merges the named vectors into a
single vector. The resulting vector is formed by merging the
components of each source vector one index at a time.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>notify</b>
<i>keyword</i></p>

<p style="margin-left:22%;">Controls how vector clients are
notified of changes to the vector. The exact behavior is
determined by <i>keyword</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><tt>always</tt></p></td>
<td width="1%"></td>
<td width="68%">


<p>Indicates that clients are to be notified immediately
whenever the vector is updated.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><tt>never</tt></p></td>
<td width="1%"></td>
<td width="68%">


<p>Indicates that no clients are to be notified.</p></td></tr>
</table>

<p style="margin-left:22%;"><tt>whenidle</tt></p>

<p style="margin-left:32%;">Indicates that clients are to
be notified at the next idle point whenever the vector is
updated.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><tt>now</tt></p></td>
<td width="1%"></td>
<td width="68%">


<p>If any client notifications is currently pending, they
are notified immediately.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><tt>cancel</tt></p></td>
<td width="1%"></td>
<td width="68%">


<p>Cancels pending notifications of clients using the
vector.</p> </td></tr>
</table>

<p style="margin-left:22%;"><tt>pending</tt></p>

<p style="margin-left:32%;">Returns <tt>1</tt> if a client
notification is pending, and <tt>0</tt> otherwise.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>offset</b>
?<i>value</i>?</p>

<p style="margin-left:22%;">Shifts the indices of the
vector by the amount specified by <i>value</i>. <i>Value</i>
is an integer number. If no <i>value</i> argument is given,
the current offset is returned.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>populate</b>
<i>destName</i> ?<i>density</i>?</p>

<p style="margin-left:22%;">Creates a vector
<i>destName</i> which is a superset of <i>vecName</i>.
<i>DestName</i> will include all the components of
<i>vecName</i>, in addition the interval between each of the
original components will contain a <i>density</i> number of
new components, whose values are evenly distributed between
the original components values. This is useful for
generating abscissas to be interpolated along a spline.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>range</b>
<i>firstIndex</i> ?<i>lastIndex</i>?...</p>

<p style="margin-left:22%;">Returns a list of numeric
values representing the vector components between two
indices. Both <i>firstIndex</i> and <i>lastIndex</i> are
indices representing the range of components to be returned.
If <i>lastIndex</i> is less than <i>firstIndex</i>, the
components are listed in reverse order.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>search</b>
<i>value</i> ?<i>value</i>?</p>

<p style="margin-left:22%;">Searches for a value or range
of values among the components of <i>vecName</i>. If one
<i>value</i> argument is given, a list of indices of the
components which equal <i>value</i> is returned. If a second
<i>value</i> is also provided, then the indices of all
components which lie within the range of the two values are
returned. If no components are found, then
<tt>&quot;&quot;</tt> is returned.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>set</b>
<i>item</i></p>

<p style="margin-left:22%;">Resets the components of the
vector to <i>item</i>. <i>Item</i> can be either a list of
numeric expressions or another vector.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>seq</b>
<i>start</i> ?<i>finish</i>? ?<i>step</i>?</p>

<p style="margin-left:22%;">Generates a sequence of values
starting with the value <i>start</i>. <i>Finish</i>
indicates the terminating value of the sequence. The vector
is automatically resized to contain just the sequence. If
three arguments are present, <i>step</i> designates the
interval.</p>

<p style="margin-left:22%; margin-top: 1em">With only two
arguments (no <i>finish</i> argument), the sequence will
continue until the vector is filled. With one argument, the
interval defaults to 1.0.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>sort</b>
?<b>-reverse</b>? ?<i>argName</i>?...</p>

<p style="margin-left:22%;">Sorts the vector <i>vecName</i>
in increasing order. If the <b>-reverse</b> flag is present,
the vector is sorted in decreasing order. If other arguments
<i>argName</i> are present, they are the names of vectors
which will be rearranged in the same manner as
<i>vecName</i>. Each vector must be the same length as
<i>vecName</i>. You could use this to sort the x vector of a
graph, while still retaining the same x,y coordinate pairs
in a y vector.</p>

<p style="margin-left:11%;"><i>vecName</i> <b>variable</b>
<i>varName</i></p>

<p style="margin-left:22%;">Maps a Tcl variable to the
vector, creating another means for accessing the vector. The
variable <i>varName</i> can&rsquo;t already exist. This
overrides any current variable mapping the vector may
have.</p>

<h2>C LANGUAGE API
<a name="C LANGUAGE API"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">You can create,
modify, and destroy vectors from C code, using library
routines. You need to include the header file
<tt>blt.h</tt>. It contains the definition of the structure
<b>Blt_Vector</b>, which represents the vector. It appears
below.</p>

<p style="margin-left:22%; margin-top: 1em">typedef struct
{ <br>
double *<i>valueArr</i>; <br>
int <i>numValues</i>; <br>
int <i>arraySize</i>; <br>
double <i>min</i>, <i>max</i>; <br>
} <b>Blt_Vector</b>;</p>

<p style="margin-left:11%; margin-top: 1em">The field
<i>valueArr</i> points to memory holding the vector
components. The components are stored in a double precision
array, whose size size is represented by <i>arraySize</i>.
<i>NumValues</i> is the length of vector. The size of the
array is always equal to or larger than the length of the
vector. <i>Min</i> and <i>max</i> are minimum and maximum
component values.</p>

<h2>LIBRARY ROUTINES
<a name="LIBRARY ROUTINES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
routines are available from C to manage vectors. Vectors are
identified by the vector name.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Blt_CreateVector</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="14%">


<p>Synopsis:</p></td>
<td width="1%"></td>
<td width="71%">


<p><tt>int</tt> <b>Blt_CreateVector</b> (<i>interp</i>,
<i>vecName</i>, <i>length</i>, <i>vecPtrPtr</i>)</p></td></tr>
</table>

<p style="margin-left:49%;">Tcl_Interp *<i>interp</i>; <br>
char *<i>vecName</i>; <br>
int <i>length</i>; <br>
Blt_Vector **<i>vecPtrPtr</i>;</p>

<p style="margin-left:14%;">Description:</p>

<p style="margin-left:29%;">Creates a new vector
<i>vecName</i> with a length of <i>length</i>.
<b>Blt_CreateVector</b> creates both a new Tcl command and
array variable <i>vecName</i>. Neither a command nor
variable named <i>vecName</i> can already exist. A pointer
to the vector is placed into <i>vecPtrPtr</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="12%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="71%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
created. If <i>length</i> is negative, a Tcl variable or
command <i>vecName</i> already exists, or memory cannot be
allocated for the vector, then <tt>TCL_ERROR</tt> is
returned and <i>interp-&gt;result</i> will contain an error
message.</p> </td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Blt_DeleteVectorByName</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="1%"></td>
<td width="68%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_DeleteVectorByName</b> (<i>interp</i>,
<i>vecName</i>)</p> </td>
<td width="3%">
</td></tr>
</table>

<p style="margin-left:49%;">Tcl_Interp *<i>interp</i>; <br>
char *<i>vecName</i>;</p>

<p style="margin-left:14%;">Description:</p>

<p style="margin-left:29%;">Removes the vector
<i>vecName</i>. <i>VecName</i> is the name of a vector which
must already exist. Both the Tcl command and array variable
<i>vecName</i> are destroyed. All clients of the vector will
be notified immediately that the vector has been
destroyed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="12%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="71%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
deleted. If <i>vecName</i> is not the name a vector, then
<tt>TCL_ERROR</tt> is returned and <i>interp-&gt;result</i>
will contain an error message.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Blt_DeleteVector</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="1%"></td>
<td width="45%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_DeleteVector</b> (<i>vecPtr</i>)</p></td>
<td width="26%">
</td></tr>
</table>

<p style="margin-left:49%;">Blt_Vector *<i>vecPtr</i>;</p>

<p style="margin-left:14%;">Description:</p>

<p style="margin-left:29%;">Removes the vector pointed to
by <i>vecPtr</i>. <i>VecPtr</i> is a pointer to a vector,
typically set by <b>Blt_GetVector</b> or
<b>Blt_CreateVector</b>. Both the Tcl command and array
variable of the vector are destroyed. All clients of the
vector will be notified immediately that the vector has been
destroyed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="12%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="71%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
deleted. If <i>vecName</i> is not the name a vector, then
<tt>TCL_ERROR</tt> is returned and <i>interp-&gt;result</i>
will contain an error message.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Blt_GetVector</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="1%"></td>
<td width="71%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_GetVector</b> (<i>interp</i>, <i>vecName</i>,
<i>vecPtrPtr</i>)</p> </td></tr>
</table>

<p style="margin-left:49%;">Tcl_Interp *<i>interp</i>; <br>
char *<i>vecName</i>; <br>
Blt_Vector **<i>vecPtrPtr</i>;</p>

<p style="margin-left:14%;">Description:</p>

<p style="margin-left:29%;">Retrieves the vector
<i>vecName</i>. <i>VecName</i> is the name of a vector which
must already exist. <i>VecPtrPtr</i> will point be set to
the address of the vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="12%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="71%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
retrieved. If <i>vecName</i> is not the name of a vector,
then <tt>TCL_ERROR</tt> is returned and
<i>interp-&gt;result</i> will contain an error message.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Blt_ResetVector</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="3%"></td>
<td width="25%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="1%"></td>
<td width="57%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_ResetVector</b> (<i>vecPtr</i>, <i>dataArr</i>,</p></td>
<td width="14%">
</td></tr>
<tr valign="top" align="left">
<td width="3%"></td>
<td width="25%"></td>
<td width="1%"></td>
<td width="57%">


<p><i>numValues</i>, <i>arraySize</i>, <i>freeProc</i>)</p></td>
<td width="14%">
</td></tr>
</table>

<p style="margin-left:49%;">Blt_Vector *<i>vecPtr</i>; <br>
double *<i>dataArr</i>; <br>
int *<i>numValues</i>; <br>
int *<i>arraySize</i>; <br>
Tcl_FreeProc *<i>freeProc</i>;</p>

<p style="margin-left:14%;">Description:</p>

<p style="margin-left:29%;">Resets the components of the
vector pointed to by <i>vecPtr</i>. Calling
<b>Blt_ResetVector</b> will trigger the vector to dispatch
notifications to its clients. <i>DataArr</i> is the array of
doubles which represents the vector data. <i>NumValues</i>
is the number of elements in the array. <i>ArraySize</i> is
the actual size of the array (the array may be bigger than
the number of values stored in it). <i>FreeProc</i>
indicates how the storage for the vector component array
(<i>dataArr</i>) was allocated. It is used to determine how
to reallocate memory when the vector is resized or
destroyed. It must be <tt>TCL_DYNAMIC</tt>,
<tt>TCL_STATIC</tt>, <tt>TCL_VOLATILE</tt>, or a pointer to
a function to free the memory allocated for the vector
array. If <i>freeProc</i> is <tt>TCL_VOLATILE</tt>, it
indicates that <i>dataArr</i> must be copied and saved. If
<i>freeProc</i> is <tt>TCL_DYNAMIC</tt>, it indicates that
<i>dataArr</i> was dynamically allocated and that Tcl should
free <i>dataArr</i> if necessary. <tt>Static</tt> indicates
that nothing should be done to release storage for
<i>dataArr</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="12%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="71%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
resized. If <i>newSize</i> is negative, a vector
<i>vecName</i> does not exist, or memory cannot be allocated
for the vector, then <tt>TCL_ERROR</tt> is returned and
<i>interp-&gt;result</i> will contain an error message.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><b>Blt_ResizeVector</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="1%"></td>
<td width="59%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_ResizeVector</b> (<i>vecPtr</i>, <i>newSize</i>)</p></td>
<td width="12%">
</td></tr>
</table>

<p style="margin-left:49%;">Blt_Vector *<i>vecPtr</i>; <br>
int <i>newSize</i>;</p>

<p style="margin-left:14%;">Description:</p>

<p style="margin-left:29%;">Resets the length of the vector
pointed to by <i>vecPtr</i> to <i>newSize</i>. If
<i>newSize</i> is smaller than the current size of the
vector, it is truncated. If <i>newSize</i> is greater, the
vector is extended and the new components are initialized to
<tt>0.0</tt>. Calling <b>Blt_ResetVector</b> will trigger
the vector to dispatch notifications.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="14%"></td>
<td width="12%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="71%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
resized. If <i>newSize</i> is negative or memory can not be
allocated for the vector, then <tt>TCL_ERROR</tt> is
returned and <i>interp-&gt;result</i> will contain an error
message.</p> </td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>Blt_VectorExists</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="58%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_VectorExists</b> (<i>interp</i>, <i>vecName</i>)</p></td>
<td width="8%">
</td></tr>
</table>

<p style="margin-left:52%;">Tcl_Interp *<i>interp</i>; <br>
char *<i>vecName</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Indicates if a vector named
<i>vecName</i> exists in <i>interp</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>Returns <tt>1</tt> if a vector <i>vecName</i> exists and
<tt>0</tt> otherwise.</p></td></tr>
</table>

<p style="margin-left:14%; margin-top: 1em">If your
application needs to be notified when a vector changes, it
can allocate a unique <i>client identifier</i> for itself.
Using this identifier, you can then register a call-back to
be made whenever the vector is updated or destroyed. By
default, the call-backs are made at the next idle point.
This can be changed to occur at the time the vector is
modified. An application can allocate more than one
identifier for any vector. When the client application is
done with the vector, it should free the identifier.</p>

<p style="margin-left:14%; margin-top: 1em">The call-back
routine must of the following type.</p>

<p style="margin-left:35%; margin-top: 1em"><tt>typedef
void (</tt><b>Blt_VectorChangedProc</b>) (Tcl_Interp
*<i>interp</i>,</p>

<p style="margin-left:40%;">ClientData <i>clientData</i>,
Blt_VectorNotify <i>notify</i>);</p>


<p style="margin-left:14%; margin-top: 1em"><i>ClientData</i>
is passed to this routine whenever it is called. You can use
this to pass information to the call-back. The <i>notify</i>
argument indicates whether the vector has been updated of
destroyed. It is an enumerated type.</p>

<pre style="margin-left:35%; margin-top: 1em">typedef enum {
    BLT_VECTOR_NOTIFY_UPDATE=1,
    BLT_VECTOR_NOTIFY_DESTROY=2
}<b> Blt_VectorNotify</b>;</pre>



<p style="margin-left:14%; margin-top: 1em"><b>Blt_AllocVectorId</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em"><tt>Blt_VectorId</tt>
<b>Blt_AllocVectorId</b> (<i>interp</i>, <i>vecName</i>)</p></td></tr>
</table>

<p style="margin-left:52%;">Tcl_Interp *<i>interp</i>; <br>
char *<i>vecName</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Allocates an client identifier
for with the vector <i>vecName</i>. This identifier can be
used to specify a call-back which is triggered when the
vector is updated or destroyed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>Returns a client identifier if successful. If
<i>vecName</i> is not the name of a vector, then
<tt>NULL</tt> is returned and <i>interp-&gt;result</i> will
contain an error message.</p></td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>Blt_GetVectorById</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em"><tt>int</tt>
<b>Blt_GetVector</b> (<i>interp</i>, <i>clientId</i>,
<i>vecPtrPtr</i>)</p> </td></tr>
</table>

<p style="margin-left:52%;">Tcl_Interp *<i>interp</i>; <br>
Blt_VectorId <i>clientId</i>; <br>
Blt_Vector **<i>vecPtrPtr</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Retrieves the vector used by
<i>clientId</i>. <i>ClientId</i> is a valid vector client
identifier allocated by <b>Blt_AllocVectorId</b>.
<i>VecPtrPtr</i> will point be set to the address of the
vector.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>Returns <tt>TCL_OK</tt> if the vector is successfully
retrieved.</p> </td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>Blt_SetVectorChangedProc</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em"><tt>void</tt>
<b>Blt_SetVectorChangedProc</b> (<i>clientId</i>,
<i>proc</i>, <i>clientData</i>);</p></td></tr>
</table>

<p style="margin-left:52%;">Blt_VectorId <i>clientId</i>;
<br>
Blt_VectorChangedProc *<i>proc</i>; <br>
ClientData *<i>clientData</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Specifies a call-back routine
to be called whenever the vector associated with
<i>clientId</i> is updated or deleted. <i>Proc</i> is a
pointer to call-back routine and must be of the type
<b>Blt_VectorChangedProc</b>. <i>ClientData</i> is a
one-word value to be passed to the routine when it is
invoked. If <i>proc</i> is <tt>NULL</tt>, then the client is
not notified.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>The designated call-back procedure will be invoked when
the vector is updated or destroyed.</p></td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>Blt_FreeVectorId</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="51%">


<p style="margin-top: 1em"><tt>void</tt>
<b>Blt_FreeVectorId</b> (<i>clientId</i>);</p></td>
<td width="15%">
</td></tr>
</table>

<p style="margin-left:52%;">Blt_VectorId
<i>clientId</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Frees the client identifier.
Memory allocated for the identifier is released. The client
will no longer be notified when the vector is modified.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>The designated call-back procedure will be no longer be
invoked when the vector is updated or destroyed.</p></td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>Blt_NameOfVectorId</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="55%">


<p style="margin-top: 1em"><tt>char
*</tt><b>Blt_NameOfVectorId</b> (<i>clientId</i>);</p></td>
<td width="11%">
</td></tr>
</table>

<p style="margin-left:52%;">Blt_VectorId
<i>clientId</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Retrieves the name of the
vector associated with the client identifier
<i>clientId</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>Returns the name of the vector associated with
<i>clientId</i>. If <i>clientId</i> is not an identifier or
the vector has been destroyed, <tt>NULL</tt> is
returned.</p> </td></tr>
</table>


<p style="margin-left:14%; margin-top: 1em"><b>Blt_InstallIndexProc</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="14%">


<p style="margin-top: 1em">Synopsis:</p></td>
<td width="2%"></td>
<td width="66%">


<p style="margin-top: 1em"><tt>void</tt>
<b>Blt_InstallIndexProc</b> (<i>indexName</i>,
<i>procPtr</i>)</p> </td></tr>
</table>

<p style="margin-left:52%;">char *<i>indexName</i>; <br>
Blt_VectorIndexProc *<i>procPtr</i>;</p>

<p style="margin-left:18%;">Description:</p>

<p style="margin-left:34%;">Registers a function to be
called to retrieved the index <i>indexName</i> from the
vector&rsquo;s array variable.</p>

<p style="margin-left:34%; margin-top: 1em">typedef double
Blt_VectorIndexProc(Vector *vecPtr);</p>

<p style="margin-left:34%; margin-top: 1em">The function
will be passed a pointer to the vector. The function must
return a double representing the value at the index.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="18%"></td>
<td width="13%">


<p>Results:</p></td>
<td width="3%"></td>
<td width="66%">


<p>The new index is installed into the vector.</p></td></tr>
</table>

<h2>C API EXAMPLE
<a name="C API EXAMPLE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The following
example opens a file of binary data and stores it in an
array of doubles. The array size is computed from the size
of the file. If the vector &quot;data&quot; exists, calling
<b>Blt_VectorExists</b>, <b>Blt_GetVector</b> is called to
get the pointer to the vector. Otherwise the routine
<b>Blt_CreateVector</b> is called to create a new vector and
returns a pointer to it. Just like the Tcl interface, both a
new Tcl command and array variable are created when a new
vector is created. It doesn&rsquo;t make any difference what
the initial size of the vector is since it will be reset
shortly. The vector is updated when <b>lt_ResetVector</b> is
called. Blt_ResetVector makes the changes visible to the Tcl
interface and other vector clients (such as a graph
widget).</p>
<pre style="margin-left:22%; margin-top: 1em">#include &lt;tcl.h&gt;
#include &lt;blt.h&gt;
Blt_Vector *vecPtr;
double *newArr;
FILE *f;
struct stat statBuf;
int numBytes, numValues;

f = fopen(&quot;binary.dat&quot;, &quot;r&quot;);
fstat(fileno(f), &amp;statBuf);
numBytes = (int)statBuf.st_size;

/* Allocate an array big enough to hold all the data */
newArr = (double *)malloc(numBytes);
numValues = numBytes / sizeof(double);
fread((void *)newArr, numValues, sizeof(double), f);
fclose(f);


if (Blt_VectorExists(interp, &quot;data&quot;))  {
    if (Blt_GetVector(interp, &quot;data&quot;, &amp;vecPtr) != TCL_OK) {
  return TCL_ERROR;
    }
} else {
   if (Blt_CreateVector(interp, &quot;data&quot;, 0, &amp;vecPtr) != TCL_OK) {
  return TCL_ERROR;
   }
}
/*
 * Reset the vector. Clients will be notified when Tk is idle.
 * TCL_DYNAMIC tells the vector to free the memory allocated
 * if it needs to reallocate or destroy the vector.
 */
if (Blt_ResetVector(vecPtr, newArr, numValues, numValues,
  TCL_DYNAMIC) != TCL_OK) {
    return TCL_ERROR;
}</pre>


<h2>INCOMPATIBILITIES
<a name="INCOMPATIBILITIES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">In previous
versions, if the array variable isn&rsquo;t global (i.e.
local to a Tcl procedure), the vector is automatically
destroyed when the procedure returns.</p>

<pre style="margin-left:22%; margin-top: 1em">proc doit {} {
    # Temporary vector x
    vector x(10)
    set x(9) 2.0
      ...
}</pre>


<p style="margin-left:11%; margin-top: 1em">This has
changed. Variables are not automatically destroyed when
their variable is unset. You can restore the old behavior by
setting the &quot;-watchunset&quot; switch.</p>

<h2>KEYWORDS
<a name="KEYWORDS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">vector, graph,
widget</p>
<hr>
</body>
</html>
